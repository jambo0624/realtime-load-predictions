# Google Cluster Workload Tracking Data Format Description

## Cluster Basic Concepts
A Google cluster is a collection of machines installed in physical racks and connected by a high-bandwidth cluster network. A cell is a collection of machines that share the same cluster management system, usually located in the same cluster. The cluster management system assigns work to the machines.

Borg supports two types of resource request:
- **Job**：Consists of one or more tasks, describing the user's desired computational job.
- **Alloc set**：Consists of one or more alloc instances, describing the resource reservation environment available for tasks to run.

A single task instance (task) represents a Linux program (possibly containing multiple processes) running on a single machine. The task can specify a required alloc set, in which case each task instance will obtain resources from a specific alloc instance in the alloc set. If the task does not specify an alloc set, its task instances will directly obtain resources from the machine.

We refer to tasks and alloc sets as "collections" and task instances and alloc instances as "instances", and use "thing" to generically refer to collections or instances.

## Data Table Common Fields

### Data De-identification
Due to confidentiality reasons, we have de-identified certain information in the tracking data. Specifically:
- Most free-text fields were hashed
- Resource sizes were linearly transformed (scaled)
- Certain values were mapped to a sorted sequence

We ensure that these processing methods are consistent, so that the data can still be used for research.

The de-identification conversion types include:
- **Not processed**：Values remain unchanged
- **Hashing**：Hashed using a key to produce an irreversible value
- **Ordered mapping**：Values are mapped to a sorted sequence of consecutive integers (starting from 0)
- **Scaling**：Divided by a type-specific constant to normalize to the [0,1] range, and rounded to 10 binary precision
- **Special handling**：A few values were processed using special methods

### Time and Timestamp
Each record contains a timestamp in microseconds, representing the time since the tracking period started, minus 600 seconds (64-bit integer). For example, an event that occurred 20 seconds after the tracking period started has a timestamp of 620,000,000 microseconds.

Special time values:
- `0`：Represents an event that occurred before the tracking period started
- `2^63-1`(MAXINT)：Represents an event that occurred after the tracking period ended

The time processing in usage measurements is slightly different, as the maximum measurement length is 300 seconds. We apply the same time offset to ensure clear separation.

### Unique Identifier
Each collection (task, alloc set) and each machine is assigned a unique 64-bit identifier. These IDs are not reused, but machine IDs may remain unchanged when removed and re-joined the cluster. In rare cases, collection IDs may remain unchanged when stopped, reconfigured, and restarted.

Task instances are identified by the ID of their parent task and the index of the task instance within the task (starting from 0). Task instances with the same task ID and task index can (and often do) be stopped and restarted without being assigned a new ID. Alloc instances also have a similar lifecycle.

### User and Collection Names
User names and collection names are provided in the form of an opaque base64 encoded string, which supports only equality testing.

The logical collection name is a normalized name generated from multiple internal name fields using a heuristic method, which is then hashed to produce an opaque base64 encoded string (e.g., most numeric values in the logical name are replaced with a fixed string). The logical name of automatic collections generated by different program executions is usually the same.

### Resource Units
Resource requests and usage measurements are both normalized and scaled:

- **Memory**：Scaled by dividing by the maximum machine memory value observed in all tracking
- **CPU**：Scaled to normalized compute units (NCU) by a similar method to memory
- Most resources are described using a Resources structure containing CPU (NCU) and memory (normalized bytes)

## Data Table Details

### Machine Table

#### Machine Events Table (MachineEvents)
| Field | Description |
|------|------|
| time | Timestamp |
| machine_id | Machine unique ID |
| type | Event type: ADD/REMOVE/UPDATE |
| switch_id | Network switch ID the machine is connected to |
| capacity | Machine's resource capacity (Resources structure) |
| platform_id | Machine microarchitecture and chipset version |
| missing_data_reason | Reason for missing data |

Machine event types:
- ADD：Machine joins the cluster
- REMOVE：Machine leaves the cluster
- UPDATE：Machine available resources change

#### MachineAttributes Table
| Field | Description |
|------|------|
| time | Timestamp |
| machine_id | Machine unique ID |
| name | Attribute name (de-identified) |
| value | Attribute value (integer or hashed string) |
| deleted | Deleted flag |

### Collection and Instance Tables

#### Collection Events Table (CollectionEvents)
| Field | Description |
|------|------|
| time | Timestamp |
| type | Event type |
| collection_id | Collection unique ID |
| scheduling_class | Scheduling class (0-3) |
| missing_type | Missing record type |
| collection_type | 0=Task,1=Alloc collection |
| priority | Priority (higher value means higher priority) |
| alloc_collection_id | Alloc collection ID |
| user | Submitter (hashed) |
| collection_name | Collection full name (hashed) |
| collection_logical_name | Collection logical name (hashed) |
| parent_collection_id | Parent collection ID |
| start_after_collection_ids | List of preceding collection IDs |
| max_per_machine | Maximum instances per machine |
| max_per_switch | Maximum instances per switch |
| vertical_scaling | Automatic scaling settings |
| scheduler | Scheduler type |

#### Instance Events Table (InstanceEvents)
| Field | Description |
|------|------|
| time | Timestamp |
| type | Event type |
| collection_id | Collection ID |
| scheduling_class | Scheduling class |
| missing_type | Missing record type |
| collection_type | Collection type |
| priority | Priority |
| alloc_collection_id | Alloc collection ID |
| instance_index | Instance index |
| machine_id | Machine ID |
| alloc_instance_index | Alloc instance index |
| resource_request | Resource request (Resources structure) |
| constraint | Machine constraints |

#### InstanceUsage Table
| Field | Description |
|------|------|
| start_time | Measurement start time |
| end_time | Measurement end time |
| collection_id | Collection ID |
| instance_index | Instance index |
| machine_id | Machine ID |
| alloc_collection_id | Alloc collection ID |
| alloc_instance_index | Alloc instance index |
| collection_type | Collection type |
| average_usage | Average usage (Resources) |
| maximum_usage | Maximum usage (Resources) |
| random_sampled_usage | Random sampled usage (Resources) |
| assigned_memory | Assigned memory limit |
| page_cache_memory | Page cache memory |
| cycles_per_instruction | Cycles per instruction (CPI) |
| memory_accesses_per_instruction | Memory accesses per instruction (MAI) |
| sample_rate | Sample rate (Hz) |
| cpu_usage_distribution | CPU usage distribution (11th percentile) |
| tail_cpu_usage_distribution | CPU usage tail distribution (91-99th percentile) |

## Event Type Detailed Description

### Collection and Instance Lifecycle Events
| Event Type | Description |
|---------|------|
| SUBMIT | Thing submitted to cluster manager |
| QUEUE | Thing entered queue waiting for scheduling |
| ENABLE | Thing became schedulable |
| SCHEDULE | Thing scheduled to a machine (may not run immediately) |
| EVICT | Thing evicted due to high priority task, resource over-provisioning, or machine failure |
| FAIL | Thing failed due to program error (e.g., segmentation fault, memory overflow) |
| FINISH | Thing finished normally |
| KILL | Thing killed by user or driver |
| LOST | Thing terminated but missing records in source data |
| UPDATE_PENDING | Waiting for scheduling thing's scheduling class/resource demand/constraint updated |
| UPDATE_RUNNING | Running thing's scheduling class/resource demand/constraint updated |

### Missing Record Types
| Type | Description |
|-----|------|
| SNAPSHOT_BUT_NO_TRANSITION | Snapshot shows state change but missing corresponding event record |
| NO_SNAPSHOT_OR_TRANSITION | Thing disappeared from cluster state snapshot but no termination record |
| EXISTS_BUT_NO_CREATION | Thing exists but missing creation record |
| TRANSITION_MISSING_STEP | State transition missing intermediate step record |

## Resource Usage Measurement Details

### CPU Usage Measurement
- Sampling frequency: about 1 sample per second
- Calculation formula:
  - Window average CPU usage = ∑(Ucpu) / Twindow
  - Maximum CPU usage = max(Ucpu/Tsample)
- All original data is normalized to NCU values
- CPU usage unit: NCU-s/s (a task using 2 GCUs continuously will show as 2.0 GCU-s/s)

### Memory Usage Measurement
- Sampling frequency: collected every sampling period
- Calculation formula:
  - Window average memory usage = ∑(Umem×Tsample) / Twindow
  - Maximum memory usage = max(Umem)
- All original data is normalized

### Performance Metrics
- **CPI**(Cycles Per Instruction)：Cycles per instruction
- **MAI**(Memory Accesses Per Instruction)：Memory accesses per instruction
- Data source: Processor performance counters (not collected on all machines)

## Constraint Handling

### Machine Constraint Structure
| Field | Description |
|------|------|
| name | Constraint attribute name (hashed) |
| value | Constraint value (hashed string/integer/null) |
| relation | Comparison operator |

### Comparison Operator Types
| Operator | Matching condition |
|-------|----------|
| EQUAL | Machine attribute value equals constraint value |
| NOT_EQUAL | Machine attribute value does not equal constraint value |
| LESS_THAN | Machine attribute value (integer) is less than constraint value |
| LESS_THAN_EQUAL | Machine attribute value is less than or equal to constraint value |
| GREATER_THAN | Machine attribute value is greater than constraint value |
| GREATER_THAN_EQUAL | Machine attribute value is greater than or equal to constraint value |
| PRESENT | Machine has this attribute |
| NOT_PRESENT | Machine does not have this attribute |

## Priority Hierarchy Detailed Explanation
| Priority range | Level | Characteristics |
|-----------|------|------|
| 0-99 | Free tier | Low internal billing, no SLO guarantees |
| 100-115 | Batch processing tier | Managed by batch scheduler, low internal billing |
| 116-119 | Middle tier | SLO between free tier and production tier |
| 120-359 | Production tier | Highest priority, preventing delay-sensitive tasks from being evicted |
| ≥360 | Monitoring tier | Used to monitor the health of other tasks |

## Container Resource Isolation Description
- Use Linux containers for resource isolation and usage statistics
- Each task runs in an independent container (may contain multiple processes)
- Alloc instances also have associated containers (task container nested within)
- Memory isolation is implemented using Linux memcg, and some kernel memory usage is counted as task usage

## Measurement Window Characteristics
- Typical length: 5 minutes (300 seconds)
- Possible shortening:
  - When instance starts/stops
  - When instance updates
- Measurement may continue for several tens of seconds after instance termination
- Some measurement records may be missing due to system limitations

## File Format Description
The original field definitions are based on the [clusterdata_trace_format_v3.proto](https://github.com/google/cluster-data) file in GitHub, and this document is a commentary on that file.